{
  "project": "PLANY App",
  "branchName": "ralph/business-logic-db-migration",
  "description": "Migrate DB to full business logic: acceptance flow, orders, contracts, realization tracking, UX aggregation functions",
  "baseBranch": "main",
  "userStories": [
    {
      "id": "US-001",
      "title": "DB migration: enum types + ALTER existing tables + prevent_unlock trigger",
      "description": "As a developer, I need the foundational types and columns for the new business logic: 3 new enums, 2 ALTER columns on existing tables, and a trigger preventing unlock of accepted revisions.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: business_logic_types_and_alters) with the following SQL",
        "CREATE TYPE zamowienie_status AS ENUM ('draft', 'wyslane', 'czesciowo', 'dostarczone', 'rozliczone')",
        "CREATE TYPE umowa_status AS ENUM ('draft', 'wyslana', 'podpisana', 'wykonana', 'rozliczona')",
        "CREATE TYPE realizacja_wpis_typ AS ENUM ('material', 'robocizna', 'inny')",
        "ALTER TABLE rewizje ADD COLUMN is_accepted BOOLEAN DEFAULT FALSE",
        "ALTER TABLE rewizje ADD COLUMN accepted_at TIMESTAMPTZ",
        "ALTER TABLE projekty ADD COLUMN accepted_rewizja_id UUID REFERENCES rewizje(id)",
        "CREATE FUNCTION trigger_prevent_unlock_accepted() that raises exception if OLD.is_accepted=TRUE AND NEW.is_locked=FALSE, also raises if OLD.is_accepted=TRUE AND NEW.is_accepted=FALSE",
        "CREATE TRIGGER rewizje_prevent_unlock_accepted BEFORE UPDATE ON rewizje FOR EACH ROW EXECUTE FUNCTION trigger_prevent_unlock_accepted()",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Applied via Supabase MCP apply_migration. All 3 enums, 3 ALTER columns, trigger function + trigger created successfully.",
      "dependsOn": []
    },
    {
      "id": "US-002",
      "title": "DB migration: zamowienia tables (5 tables)",
      "description": "As a developer, I need the 5 order-related tables: zamowienia, zamowienie_pozycje, zamowienie_pozycje_zrodla, zamowienie_dostawy, zamowienie_dostawy_pozycje.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: zamowienia_tables) with CREATE TABLE statements",
        "zamowienia: id UUID PK, organization_id UUID FK NOT NULL, projekt_id UUID FK NOT NULL, rewizja_id UUID FK NOT NULL, dostawca_id UUID FK NOT NULL, numer VARCHAR(50) NOT NULL, status zamowienie_status DEFAULT 'draft', data_zamowienia DATE, data_dostawy_planowana DATE, uwagi TEXT, created_at, updated_at, CONSTRAINT zamowienia_numer_unique UNIQUE(organization_id, numer)",
        "zamowienie_pozycje: id UUID PK, zamowienie_id UUID FK NOT NULL ON DELETE CASCADE, produkt_id UUID FK ON DELETE SET NULL, nazwa VARCHAR(255) NOT NULL, jednostka VARCHAR(20), ilosc_zamowiona DECIMAL(12,3) NOT NULL, cena_jednostkowa DECIMAL(12,2) NOT NULL, wartosc DECIMAL(14,2) GENERATED ALWAYS AS (ilosc_zamowiona * cena_jednostkowa) STORED, ilosc_dostarczona DECIMAL(12,3) DEFAULT 0, created_at",
        "zamowienie_pozycje_zrodla: id UUID PK, zamowienie_pozycja_id UUID FK NOT NULL ON DELETE CASCADE, kosztorys_skladowa_m_id UUID FK NOT NULL references kosztorys_skladowe_materialy(id), ilosc DECIMAL(12,4) NOT NULL",
        "zamowienie_dostawy: id UUID PK, zamowienie_id UUID FK NOT NULL ON DELETE CASCADE, data_dostawy DATE NOT NULL, numer_wz VARCHAR(100), uwagi TEXT, created_at",
        "zamowienie_dostawy_pozycje: id UUID PK, zamowienie_dostawa_id UUID FK NOT NULL ON DELETE CASCADE, zamowienie_pozycja_id UUID FK NOT NULL ON DELETE CASCADE, ilosc_dostarczona DECIMAL(12,3) NOT NULL",
        "All FK references use ON DELETE CASCADE where parent-child, ON DELETE SET NULL for optional references",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "All 5 zamowienia tables created successfully via Supabase MCP.",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-003",
      "title": "DB migration: umowy tables (4 tables) + realizacja_wpisy",
      "description": "As a developer, I need the 4 contract-related tables (umowy, umowa_pozycje, umowa_pozycje_zrodla, umowa_wykonanie) and the realizacja_wpisy table for cost tracking.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: umowy_realizacja_tables) with CREATE TABLE statements",
        "umowy: id UUID PK, organization_id UUID FK NOT NULL, projekt_id UUID FK NOT NULL, rewizja_id UUID FK NOT NULL, podwykonawca_id UUID FK NOT NULL, numer VARCHAR(50) NOT NULL, status umowa_status DEFAULT 'draft', data_podpisania DATE, warunki_platnosci TEXT, uwagi TEXT, created_at, updated_at, CONSTRAINT umowy_numer_unique UNIQUE(organization_id, numer)",
        "umowa_pozycje: id UUID PK, umowa_id UUID FK NOT NULL ON DELETE CASCADE, pozycja_biblioteka_id UUID FK ON DELETE SET NULL, nazwa VARCHAR(500) NOT NULL, jednostka VARCHAR(20), ilosc DECIMAL(12,3) NOT NULL, stawka DECIMAL(12,2) NOT NULL, wartosc DECIMAL(14,2) GENERATED ALWAYS AS (ilosc * stawka) STORED, ilosc_wykonana DECIMAL(12,3) DEFAULT 0, procent_wykonania DECIMAL(5,2) GENERATED ALWAYS AS (CASE WHEN ilosc > 0 THEN ROUND(ilosc_wykonana / ilosc * 100, 2) ELSE 0 END) STORED, created_at",
        "umowa_pozycje_zrodla: id UUID PK, umowa_pozycja_id UUID FK NOT NULL ON DELETE CASCADE, kosztorys_skladowa_r_id UUID FK NOT NULL references kosztorys_skladowe_robocizna(id), ilosc DECIMAL(12,4) NOT NULL",
        "umowa_wykonanie: id UUID PK, umowa_pozycja_id UUID FK NOT NULL ON DELETE CASCADE, data_wpisu DATE NOT NULL, ilosc_wykonana DECIMAL(12,3) NOT NULL, uwagi TEXT, created_at",
        "realizacja_wpisy: id UUID PK, organization_id UUID FK NOT NULL, projekt_id UUID FK NOT NULL, zamowienie_id UUID FK ON DELETE SET NULL (optional), umowa_id UUID FK ON DELETE SET NULL (optional), typ realizacja_wpis_typ NOT NULL, opis VARCHAR(500), kwota_netto DECIMAL(12,2) NOT NULL, numer_faktury VARCHAR(100), data_faktury DATE, oplacone BOOLEAN DEFAULT FALSE, created_at, updated_at",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "All 5 tables (4 umowy + realizacja_wpisy) created successfully via Supabase MCP.",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-004",
      "title": "DB migration: indexes for all new tables (27 indexes)",
      "description": "As a developer, I need performance indexes on all new tables: organization_id for RLS, FK columns for JOINs, status columns for filtering.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: business_logic_indexes) with CREATE INDEX statements",
        "Zamowienia group (7): idx_zamowienia_org, idx_zamowienia_projekt, idx_zamowienia_dostawca, idx_zamowienia_rewizja, idx_zamowienia_status, idx_zam_pozycje_zamowienie, idx_zam_pozycje_produkt",
        "Zamowienie zrodla+dostawy (5): idx_zam_poz_zrodla_pozycja, idx_zam_poz_zrodla_skladowa, idx_zam_dostawy_zamowienie, idx_zam_dost_poz_dostawa, idx_zam_dost_poz_pozycja",
        "Umowy group (7): idx_umowy_org, idx_umowy_projekt, idx_umowy_podwykonawca, idx_umowy_rewizja, idx_umowy_status, idx_umowa_pozycje_umowa, idx_umowa_pozycje_poz_bib",
        "Umowa zrodla+wykonanie (3): idx_umowa_poz_zrodla_pozycja, idx_umowa_poz_zrodla_skladowa, idx_umowa_wykonanie_pozycja",
        "Realizacja (5): idx_realizacja_org, idx_realizacja_projekt, idx_realizacja_zamowienie, idx_realizacja_umowa, idx_realizacja_typ",
        "Total: 27 indexes",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "All 27 indexes created successfully.",
      "dependsOn": ["US-002", "US-003"]
    },
    {
      "id": "US-005",
      "title": "DB migration: RLS policies for zamowienia tables (5 tables, 20 policies)",
      "description": "As a developer, I need RLS on all 5 zamowienia tables. Pattern A (direct org_id) for zamowienia. Pattern B (1 JOIN) for zamowienie_pozycje and zamowienie_dostawy. Pattern B x2 (2 JOINs) for zamowienie_pozycje_zrodla and zamowienie_dostawy_pozycje.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: rls_zamowienia) enabling RLS and creating policies",
        "ALTER TABLE ... ENABLE ROW LEVEL SECURITY on all 5 zamowienia tables",
        "zamowienia: 4 policies (SELECT/INSERT/UPDATE/DELETE) TO authenticated using organization_id IN (SELECT user_organizations()). INSERT uses WITH CHECK instead of USING",
        "zamowienie_pozycje: 4 policies using EXISTS (SELECT 1 FROM zamowienia z WHERE z.id = zamowienie_id AND z.organization_id IN (SELECT user_organizations()))",
        "zamowienie_pozycje_zrodla: 4 policies using EXISTS with JOIN through zamowienie_pozycje to zamowienia.organization_id (2 JOINs)",
        "zamowienie_dostawy: 4 policies using EXISTS through zamowienia.organization_id (1 JOIN)",
        "zamowienie_dostawy_pozycje: 4 policies using EXISTS with JOIN through zamowienie_dostawy to zamowienia.organization_id (2 JOINs)",
        "Total: 20 policies",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "All 20 RLS policies for zamowienia tables created successfully.",
      "dependsOn": ["US-002"]
    },
    {
      "id": "US-006",
      "title": "DB migration: RLS policies for umowy + realizacja tables (5 tables, 20 policies)",
      "description": "As a developer, I need RLS on umowy (4 tables) + realizacja_wpisy. Pattern A for umowy and realizacja_wpisy. Pattern B for umowa_pozycje. Pattern B x2 for umowa_pozycje_zrodla and umowa_wykonanie.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: rls_umowy_realizacja) enabling RLS and creating policies",
        "ALTER TABLE ... ENABLE ROW LEVEL SECURITY on all 5 tables",
        "umowy: 4 policies TO authenticated using organization_id IN (SELECT user_organizations())",
        "umowa_pozycje: 4 policies using EXISTS through umowy.organization_id (1 JOIN)",
        "umowa_pozycje_zrodla: 4 policies using EXISTS with JOIN through umowa_pozycje to umowy.organization_id (2 JOINs)",
        "umowa_wykonanie: 4 policies using EXISTS with JOIN through umowa_pozycje to umowy.organization_id (2 JOINs)",
        "realizacja_wpisy: 4 policies TO authenticated using organization_id IN (SELECT user_organizations())",
        "Total: 20 policies",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "All 20 RLS policies for umowy + realizacja tables created successfully.",
      "dependsOn": ["US-003"]
    },
    {
      "id": "US-007",
      "title": "DB migration: trigger functions (updated_at, auto_numer, auto_sum)",
      "description": "As a developer, I need trigger functions and triggers for: updated_at on 3 tables (reuse existing function), auto-numbering on zamowienia and umowy (ZAM/YYYY/NNN, UMW/YYYY/NNN), and auto-sum triggers for ilosc_dostarczona and ilosc_wykonana.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: business_logic_triggers)",
        "CREATE TRIGGER zamowienia_updated_at, umowy_updated_at, realizacja_wpisy_updated_at — all reuse existing trigger_updated_at() function",
        "CREATE FUNCTION trigger_auto_numer_zamowienia() — generates ZAM/YYYY/NNN format, only when numer IS NULL or empty. Uses EXTRACT(YEAR) from data_zamowienia or NOW(), LPAD with 3 digits. Scoped per organization_id",
        "CREATE TRIGGER zamowienia_auto_numer BEFORE INSERT on zamowienia",
        "CREATE FUNCTION trigger_auto_numer_umowy() — generates UMW/YYYY/NNN format, same pattern. Uses data_podpisania or NOW()",
        "CREATE TRIGGER umowy_auto_numer BEFORE INSERT on umowy",
        "CREATE FUNCTION trigger_update_zamowienie_dostarczona() — after INSERT/UPDATE/DELETE on zamowienie_dostawy_pozycje, UPDATE zamowienie_pozycje SET ilosc_dostarczona = COALESCE(SUM(...), 0)",
        "CREATE TRIGGER zam_dost_poz_update_sum AFTER INSERT OR UPDATE OR DELETE on zamowienie_dostawy_pozycje",
        "CREATE FUNCTION trigger_update_umowa_wykonana() — after INSERT/UPDATE/DELETE on umowa_wykonanie, UPDATE umowa_pozycje SET ilosc_wykonana = COALESCE(SUM(...), 0)",
        "CREATE TRIGGER umowa_wyk_update_sum AFTER INSERT OR UPDATE OR DELETE on umowa_wykonanie",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "All trigger functions and triggers created: 3x updated_at, 2x auto_numer, 2x auto_sum.",
      "dependsOn": ["US-002", "US-003"]
    },
    {
      "id": "US-008",
      "title": "DB migration: private.generate_zamowienia_draft function + public wrapper",
      "description": "As a developer, I need a Postgres function that generates draft orders from an accepted revision. Groups kosztorys_skladowe_materialy by dostawca_id, creates 1 zamowienie per dostawca with aggregated pozycje, and records source links.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: fn_generate_zamowienia_draft)",
        "CREATE FUNCTION private.generate_zamowienia_draft(p_projekt_id UUID, p_rewizja_id UUID) RETURNS INTEGER, SECURITY DEFINER",
        "Function validates rewizja is_accepted = TRUE, raises exception otherwise",
        "Loops DISTINCT dostawca_id from kosztorys_skladowe_materialy for the given rewizja (skips NULL dostawca_id)",
        "Per dostawca: INSERT zamowienia header, INSERT zamowienie_pozycje aggregated per (produkt_id, cena) with SUM of quantities using is_manual logic (is_manual ? ilosc : norma * kp.ilosc), INSERT zamowienie_pozycje_zrodla linking back to kosztorys_skladowe_materialy",
        "Returns count of created zamowienia",
        "CREATE FUNCTION generate_zamowienia_draft(p_projekt_id UUID, p_rewizja_id UUID) RETURNS INTEGER — public wrapper, SECURITY INVOKER, delegates to private function",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Private schema created, generate_zamowienia_draft function + public wrapper deployed successfully.",
      "dependsOn": ["US-002", "US-005"]
    },
    {
      "id": "US-009",
      "title": "DB migration: private.generate_umowy_draft function + public wrapper",
      "description": "As a developer, I need a Postgres function that generates draft contracts from an accepted revision. Groups kosztorys_skladowe_robocizna by podwykonawca_id, creates 1 umowa per podwykonawca with aggregated pozycje, and records source links.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: fn_generate_umowy_draft)",
        "CREATE FUNCTION private.generate_umowy_draft(p_projekt_id UUID, p_rewizja_id UUID) RETURNS INTEGER, SECURITY DEFINER",
        "Function validates rewizja is_accepted = TRUE, raises exception otherwise",
        "Loops DISTINCT podwykonawca_id from kosztorys_skladowe_robocizna for the given rewizja (skips NULL podwykonawca_id)",
        "Per podwykonawca: INSERT umowy header, INSERT umowa_pozycje aggregated per (pozycja_biblioteka_id, stawka) with SUM of quantities using is_manual logic, INSERT umowa_pozycje_zrodla linking back to kosztorys_skladowe_robocizna",
        "Returns count of created umowy",
        "CREATE FUNCTION generate_umowy_draft(p_projekt_id UUID, p_rewizja_id UUID) RETURNS INTEGER — public wrapper, SECURITY INVOKER",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": "generate_umowy_draft function + public wrapper deployed successfully.",
      "dependsOn": ["US-003", "US-006"]
    },
    {
      "id": "US-010",
      "title": "DB migration: get_podwykonawcy_aggregated function",
      "description": "As a developer, I need a Postgres function that returns podwykonawcy with aggregated stats (pozycje_count, stawka range) filterable by branza/kategoria/podkategoria/search, following the same pattern as existing get_materialy_aggregated.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: fn_get_podwykonawcy_aggregated)",
        "CREATE FUNCTION get_podwykonawcy_aggregated(p_branza TEXT DEFAULT NULL, p_kategoria TEXT DEFAULT NULL, p_podkategoria TEXT DEFAULT NULL, p_search TEXT DEFAULT NULL, p_limit INT DEFAULT 25, p_offset INT DEFAULT 0) RETURNS TABLE(...) SECURITY INVOKER",
        "Returns columns: id UUID, nazwa VARCHAR(255), specjalizacja VARCHAR(100), kontakt TEXT, aktywny BOOLEAN, pozycje_count BIGINT, najnizsza_stawka NUMERIC, najwyzsza_stawka NUMERIC, total_count BIGINT",
        "Chain: podwykonawcy LEFT JOIN stawki_podwykonawcow LEFT JOIN pozycje_biblioteka — filters by pozycje_biblioteka.kod prefix (LIKE p_branza || '.%')",
        "Search filters on nazwa ILIKE and specjalizacja ILIKE",
        "Only counts active stawki (sp.aktywny = TRUE)",
        "Results ordered by nazwa, paginated with LIMIT/OFFSET, total_count via COUNT(*) OVER()",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Function deployed successfully with all filters and aggregation logic.",
      "dependsOn": []
    },
    {
      "id": "US-011",
      "title": "DB migration: get_dostawcy_aggregated function",
      "description": "As a developer, I need a Postgres function that returns dostawcy with aggregated stats (produkty_count, pozycje_count, best price) filterable by branza/kategoria/podkategoria/search, following the same pattern as get_materialy_aggregated.",
      "acceptanceCriteria": [
        "Apply Supabase migration (name: fn_get_dostawcy_aggregated)",
        "CREATE FUNCTION get_dostawcy_aggregated(p_branza TEXT DEFAULT NULL, p_kategoria TEXT DEFAULT NULL, p_podkategoria TEXT DEFAULT NULL, p_search TEXT DEFAULT NULL, p_limit INT DEFAULT 25, p_offset INT DEFAULT 0) RETURNS TABLE(...) SECURITY INVOKER",
        "Returns columns: id UUID, nazwa VARCHAR(255), kod VARCHAR(50), kontakt TEXT, aktywny BOOLEAN, produkty_count BIGINT, pozycje_count BIGINT, najnizsza_cena NUMERIC, total_count BIGINT",
        "Chain: dostawcy LEFT JOIN ceny_dostawcow LEFT JOIN biblioteka_skladowe_materialy LEFT JOIN pozycje_biblioteka — filters by pozycje_biblioteka.kod prefix",
        "Search filters on nazwa ILIKE and kod ILIKE",
        "Only counts active ceny (cd.aktywny = TRUE)",
        "Results ordered by nazwa, paginated with LIMIT/OFFSET, total_count via COUNT(*) OVER()",
        "Migration applies without errors",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Function deployed successfully with full JOIN chain and aggregation.",
      "dependsOn": []
    },
    {
      "id": "US-012",
      "title": "Regenerate TypeScript types from Supabase",
      "description": "As a developer, I need updated TypeScript types reflecting all new tables, columns, enums, and functions.",
      "acceptanceCriteria": [
        "Use Supabase MCP generate_typescript_types to get updated types",
        "Write output to lib/supabase/database.types.ts",
        "Verify new types include: zamowienia, zamowienie_pozycje, zamowienie_pozycje_zrodla, zamowienie_dostawy, zamowienie_dostawy_pozycje, umowy, umowa_pozycje, umowa_pozycje_zrodla, umowa_wykonanie, realizacja_wpisy",
        "Verify enum types include: zamowienie_status, umowa_status, realizacja_wpis_typ",
        "Verify rewizje type has is_accepted and accepted_at columns",
        "Verify projekty type has accepted_rewizja_id column",
        "npm run build passes without errors",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Types regenerated and verified. All 10 new tables, 3 new enums, altered columns on rewizje/projekty, and 4 new functions present. npm run build passes.",
      "dependsOn": ["US-001", "US-002", "US-003", "US-004", "US-005", "US-006", "US-007", "US-008", "US-009", "US-010", "US-011"]
    }
  ]
}
