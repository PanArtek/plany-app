{
  "project": "PLANY App",
  "branchName": "ralph/tests-pozycja-powiazania",
  "description": "Integration tests verifying end-to-end relationships from POZYCJA BIBLIOTECZNA through kosztorys, umowy, zamówienia, to realizacja. Uses Vitest + real Supabase with service_role key (bypasses RLS). Each test builds a full chain from pozycja downward and verifies FK relationships, calculations, and data flow.",
  "mode": "feature",
  "baseBranch": "main",
  "userStories": [
    {
      "id": "US-001",
      "title": "Setup Vitest + test helpers + factory functions",
      "description": "Install Vitest and create the test infrastructure.\n\n**Step 1: Install dependencies**\n```bash\nnpm install -D vitest @supabase/supabase-js dotenv\n```\n(dotenv already in devDeps, @supabase/supabase-js in deps — just install vitest)\n\n**Step 2: Create `vitest.config.ts`** at project root:\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport path from 'path';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    testTimeout: 30000,\n    hookTimeout: 30000,\n    include: ['tests/**/*.test.ts'],\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, '.'),\n    },\n  },\n});\n```\n\n**Step 3: Add scripts to `package.json`:**\n```json\n\"test\": \"vitest run\",\n\"test:watch\": \"vitest\"\n```\n\n**Step 4: Create `tests/helpers/setup.ts`**\n\nThis file provides:\n\n1. **Supabase admin client** using service_role key (bypasses RLS):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\ndotenv.config({ path: '.env.local' });\n\nexport const supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY!,\n  { auth: { autoRefreshToken: false, persistSession: false } }\n);\n```\n\nIMPORTANT: The key name is `SUPABASE_SERVICE_ROLE_KEY`. Check `.env.local` for the actual variable name — it might also be `NEXT_PUBLIC_SUPABASE_ANON_KEY` with a different service role key. The service_role key bypasses RLS which is required for these tests since we don't authenticate as a real user.\n\nIf `SUPABASE_SERVICE_ROLE_KEY` is not in `.env.local`, log a clear error message explaining what's needed and where to get it (Supabase Dashboard → Settings → API → service_role key).\n\n2. **cleanupOrganization(orgId)** — deletes the org, which CASCADE-deletes all child data:\n```typescript\nexport async function cleanupOrganization(orgId: string) {\n  await supabase.from('organizations').delete().eq('id', orgId);\n}\n```\n\n3. **Factory functions** — each returns the created record:\n\n```typescript\nexport async function createTestOrganization(suffix?: string) {\n  const { data, error } = await supabase\n    .from('organizations')\n    .insert({ nazwa: `Test Org ${suffix || Date.now()}`, slug: `test-${Date.now()}-${Math.random().toString(36).slice(2, 8)}` })\n    .select()\n    .single();\n  if (error) throw new Error(`createTestOrganization: ${error.message}`);\n  return data;\n}\n\nexport async function createKategoria(orgId: string, opts: {\n  kod: string; nazwa: string; parent_id?: string;\n}) {\n  const { data, error } = await supabase\n    .from('kategorie')\n    .insert({ organization_id: orgId, kod: opts.kod, nazwa: opts.nazwa, parent_id: opts.parent_id || null })\n    .select()\n    .single();\n  if (error) throw new Error(`createKategoria: ${error.message}`);\n  return data;\n}\n```\n\nCreate similar factories for:\n- `createKategoriaHierarchy(orgId, branza, kat, podkat)` — creates 3-level hierarchy (branza→kategoria→podkategoria), returns `{ branza, kategoria, podkategoria }`\n- `createPozycjaBiblioteka(orgId, opts: { kategoria_id, kod, nazwa, jednostka, typ? })` — typ defaults to 'material'\n- `createDostawca(orgId, opts: { nazwa, kod })` — returns dostawca record\n- `createProdukt(orgId, opts: { sku, nazwa, jednostka?, kategoria? })` — returns produkt record\n- `createCenaDostawcy(opts: { dostawca_id, produkt_id, cena_netto })` — returns cena record\n- `createPodwykonawca(orgId, opts: { nazwa, specjalizacja? })` — returns podwykonawca record\n- `createStawkaPodwykonawcy(opts: { podwykonawca_id, pozycja_biblioteka_id, stawka })` — returns stawka record\n- `createBibliotekaSkladowaM(opts: { pozycja_biblioteka_id, lp, nazwa, produkt_id?, dostawca_id?, cena_domyslna?, norma_domyslna?, jednostka? })` — returns record\n- `createBibliotekaSkladowaR(opts: { pozycja_biblioteka_id, lp, opis, podwykonawca_id?, stawka_domyslna?, norma_domyslna?, jednostka? })` — returns record\n- `createProjekt(orgId, opts: { nazwa, slug?, powierzchnia? })` — returns projekt record\n- `createRewizja(opts: { projekt_id, nazwa? })` — numer is auto-generated by trigger\n- `createKosztorysPozycja(orgId, opts: { rewizja_id, pozycja_biblioteka_id?, lp, nazwa, ilosc, jednostka, narzut_percent? })` — returns record\n- `createKosztorysSkladowaR(opts: { kosztorys_pozycja_id, lp, opis, podwykonawca_id?, stawka, norma, is_manual?, ilosc?, jednostka? })` — returns record, NOTE: is_manual defaults to false, if is_manual=true then ilosc is REQUIRED (CHECK constraint)\n- `createKosztorysSkladowaM(opts: { kosztorys_pozycja_id, lp, nazwa, produkt_id?, dostawca_id?, cena, norma, is_manual?, ilosc?, jednostka? })` — returns record, same is_manual/ilosc logic\n\n**Step 5: Create a simple smoke test `tests/smoke.test.ts`:**\n```typescript\nimport { describe, it, expect, afterAll } from 'vitest';\nimport { supabase, createTestOrganization, cleanupOrganization } from './helpers/setup';\n\ndescribe('Smoke test', () => {\n  let orgId: string;\n\n  afterAll(async () => {\n    if (orgId) await cleanupOrganization(orgId);\n  });\n\n  it('can connect to Supabase and create/delete organization', async () => {\n    const org = await createTestOrganization('smoke');\n    orgId = org.id;\n    expect(org.id).toBeDefined();\n    expect(org.nazwa).toContain('Test Org');\n  });\n});\n```\n\nRun `npm run test` — smoke test must pass.",
      "acceptanceCriteria": [
        "vitest installed as devDependency",
        "vitest.config.ts exists with @ alias and 30s timeout",
        "package.json has test and test:watch scripts",
        "tests/helpers/setup.ts exports supabase client with service_role key",
        "tests/helpers/setup.ts exports cleanupOrganization function",
        "tests/helpers/setup.ts exports all factory functions listed above",
        "tests/smoke.test.ts passes — creates and deletes org",
        "npm run test passes (smoke test)",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Done. Vitest 4.0.18 installed. All factories created. Smoke test passes. Build passes. service_role key found as SUPABASE_SERVICE_ROLE_KEY in .env.local.",
      "dependsOn": []
    },
    {
      "id": "US-002",
      "title": "Test pozycja-materialy: Pozycja <-> Materiały <-> Dostawcy",
      "description": "Create `tests/pozycja-materialy.test.ts`.\n\nThis test verifies the relationship chain: pozycja_biblioteka → biblioteka_skladowe_materialy → produkty → dostawcy → ceny_dostawcow.\n\n**Setup (beforeAll):**\n1. Create test org\n2. Create kategoria hierarchy: BUD → BUD.01 → BUD.01.01\n3. Create pozycja biblioteczna: kod='BUD.01.01.001', nazwa='Ściana GK C50', jednostka='m2', typ='material'\n4. Create dostawca: Bricoman, kod='BRIC'\n5. Create 4 produkty:\n   - Profil C50 (SKU: PRF-C50, jednostka: mb)\n   - Płyta GK 12.5 (SKU: PLY-GK125, jednostka: m2)\n   - Wkręty GK (SKU: WKR-GK35, jednostka: op)\n   - Taśma papierowa (SKU: TSM-PAP, jednostka: mb)\n6. Create ceny_dostawcow for each: 8.50, 22.00, 15.00, 3.50\n7. Add 4 biblioteka_skladowe_materialy to the pozycja:\n   - lp=1, nazwa='Profil C50', produkt_id=profil, dostawca_id=bricoman, cena_domyslna=8.50, norma_domyslna=0.9, jednostka='mb'\n   - lp=2, nazwa='Płyta GK 12.5', produkt_id=plyta, dostawca_id=bricoman, cena_domyslna=22.00, norma_domyslna=1.1, jednostka='m2'\n   - lp=3, nazwa='Wkręty GK', produkt_id=wkrety, dostawca_id=bricoman, cena_domyslna=15.00, norma_domyslna=0.05, jednostka='op'\n   - lp=4, nazwa='Taśma papierowa', produkt_id=tasma, dostawca_id=bricoman, cena_domyslna=3.50, norma_domyslna=0.8, jednostka='mb'\n\n**Test: 'pozycja has 4 material components linked to products and supplier'**\n- Query biblioteka_skladowe_materialy where pozycja_biblioteka_id = pozycja.id\n- Assert count = 4\n- For each, assert produkt_id is not null and dostawca_id = bricoman.id\n- Assert lp values are 1,2,3,4\n\n**Test: 'supplier price change is visible through ceny_dostawcow'**\n- Update ceny_dostawcow for profil C50 to 9.50\n- Query ceny_dostawcow where dostawca_id=bricoman AND produkt_id=profil\n- Assert cena_netto = 9.50\n- NOTE: biblioteka_skladowe_materialy.cena_domyslna is NOT auto-updated — it's a snapshot. The test verifies that the cennik (ceny_dostawcow) itself reflects the new price.\n\n**Test: 'second supplier with different prices'**\n- Create dostawca SIG, kod='SIG'\n- Create ceny_dostawcow for the same 4 products but with different prices: 9.00, 24.00, 14.00, 4.00\n- Query ceny_dostawcow where produkt_id = profil → expect 2 records (Bricoman and SIG)\n- Query ceny_dostawcow where dostawca_id = SIG → expect 4 records\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "Test creates full chain: org → kategoria hierarchy → pozycja → dostawca → produkty → ceny → składowe",
        "Pozycja has exactly 4 biblioteka_skladowe_materialy records",
        "Each składowa linked to correct produkt_id and dostawca_id",
        "Price update in ceny_dostawcow reflects correctly",
        "Second supplier creates separate ceny_dostawcow records",
        "Both suppliers coexist for same products",
        "Cleanup deletes all test data via cascade",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Key insight: cena_domyslna in biblioteka_skladowe is a SNAPSHOT, not a live reference. ceny_dostawcow is the live price list. Tests verify both.",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-003",
      "title": "Test pozycja-robocizna: Pozycja <-> Robocizna <-> Podwykonawcy",
      "description": "Create `tests/pozycja-robocizna.test.ts`.\n\nVerifies: pozycja_biblioteka → biblioteka_skladowe_robocizna → podwykonawcy → stawki_podwykonawcow.\n\n**Setup (beforeAll):**\n1. Create test org\n2. Create kategoria hierarchy: BUD → BUD.01 → BUD.01.01\n3. Create pozycja: kod='BUD.01.01.001', nazwa='Ściana GK C50', jednostka='m2', typ='robocizna'\n4. Create podwykonawca: 'Ekipa GK Kowalski', specjalizacja='gipskarton'\n5. Create stawka_podwykonawcy: podwykonawca_id=kowalski, pozycja_biblioteka_id=pozycja, stawka=45.00\n6. Add 3 biblioteka_skladowe_robocizna:\n   - lp=1, opis='Montaż profili', podwykonawca_id=kowalski, stawka_domyslna=15.00, norma_domyslna=0.3, jednostka='rbh'\n   - lp=2, opis='Montaż płyt GK', podwykonawca_id=kowalski, stawka_domyslna=18.00, norma_domyslna=0.25, jednostka='rbh'\n   - lp=3, opis='Szpachlowanie', podwykonawca_id=kowalski, stawka_domyslna=12.00, norma_domyslna=0.2, jednostka='rbh'\n\n**Test: 'pozycja has 3 labor components linked to subcontractor'**\n- Query biblioteka_skladowe_robocizna where pozycja_biblioteka_id = pozycja.id\n- Assert count = 3\n- For each, assert podwykonawca_id = kowalski.id\n- Assert lp values 1,2,3\n\n**Test: 'stawki_podwykonawcow links subcontractor to pozycja'**\n- Query stawki_podwykonawcow where podwykonawca_id=kowalski AND pozycja_biblioteka_id=pozycja\n- Assert exactly 1 record with stawka=45.00\n\n**Test: 'second subcontractor with different rate'**\n- Create podwykonawca 'Ekipa GK Nowak', specjalizacja='gipskarton'\n- Create stawka: podwykonawca_id=nowak, pozycja_biblioteka_id=pozycja, stawka=42.00\n- Query stawki_podwykonawcow where pozycja_biblioteka_id=pozycja → expect 2 records\n- Assert stawki are 45.00 and 42.00\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "Test creates full chain: org → kategoria → pozycja → podwykonawca → stawka → składowe robocizny",
        "Pozycja has exactly 3 biblioteka_skladowe_robocizna records",
        "Each składowa linked to correct podwykonawca_id",
        "Stawka record links subcontractor to pozycja with correct rate",
        "Second subcontractor creates separate stawka record",
        "Both subcontractors coexist for same pozycja",
        "Cleanup deletes all test data via cascade",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "stawki_podwykonawcow has UNIQUE(podwykonawca_id, pozycja_biblioteka_id). Different podwykonawcy can have different stawki for the same pozycja.",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-004",
      "title": "Test pozycja-do-kosztorysu: Biblioteka -> Kosztorys with calculations",
      "description": "Create `tests/pozycja-do-kosztorysu.test.ts`.\n\nVerifies copying from library to estimate and all calculation formulas.\n\n**Setup (beforeAll):**\n1. Create test org\n2. Create full pozycja with materials and labor (reuse pattern from US-002/003):\n   - Kategoria: BUD.01.01\n   - Pozycja: BUD.01.01.001 'Ściana GK C50', m2\n   - Dostawca: Bricoman\n   - Produkty: Profil C50 (cena 8.50), Płyta GK (22.00)\n   - Podwykonawca: Kowalski\n   - Biblioteka składowe materiały: profil (norma 0.9, cena 8.50), płyta (norma 1.1, cena 22.00)\n   - Biblioteka składowe robocizna: montaż (norma 0.3, stawka 15.00), szpachlowanie (norma 0.2, stawka 12.00)\n3. Create projekt: 'Biuro Centrum', powierzchnia=1000\n4. Create rewizja (numer auto-generated to 0)\n\n**Test: 'create kosztorys pozycja from library with 320 m2'**\n- Insert kosztorys_pozycje: rewizja_id, pozycja_biblioteka_id=pozycja.id, lp=1, nazwa='Ściana GK C50', ilosc=320, jednostka='m2', narzut_percent=30\n- Insert kosztorys_skladowe_materialy (copying from library):\n  - lp=1, nazwa='Profil C50', produkt_id, dostawca_id, cena=8.50, norma=0.9, is_manual=false\n  - lp=2, nazwa='Płyta GK', produkt_id, dostawca_id, cena=22.00, norma=1.1, is_manual=false\n- Insert kosztorys_skladowe_robocizna (copying from library):\n  - lp=1, opis='Montaż profili', podwykonawca_id, stawka=15.00, norma=0.3, is_manual=false\n  - lp=2, opis='Szpachlowanie', podwykonawca_id, stawka=12.00, norma=0.2, is_manual=false\n- Query kosztorys_pozycje_view where id = created pozycja\n- **Verify calculations:**\n  - m_jednostkowy = (8.50×0.9) + (22.00×1.1) = 7.65 + 24.20 = 31.85\n  - r_jednostkowy = (15.00×0.3) + (12.00×0.2) = 4.50 + 2.40 = 6.90\n  - m_materialy = 31.85 × 320 = 10192.00\n  - r_robocizna = 6.90 × 320 = 2208.00\n  - r_plus_m = 10192 + 2208 = 12400.00\n  - narzut_wartosc = 12400 × 0.30 = 3720.00\n  - razem = 12400 × 1.30 = 16120.00\n\nUse `toBeCloseTo(expected, 2)` for decimal comparisons.\n\n**Test: 'changing quantity recalculates correctly'**\n- Update kosztorys_pozycje set ilosc = 500\n- Query view again\n- Verify: m_materialy = 31.85×500=15925, r_robocizna = 6.90×500=3450, razem = (15925+3450)×1.30 = 25187.50\n\n**Test: 'manual component adds to totals correctly'**\n- Add manual material component: lp=3, nazwa='Transport', cena=500, norma=0, ilosc=1, is_manual=true\n  (flat 500 PLN regardless of quantity)\n- Query view\n- Verify: m_materialy now includes +500 (manual). View formula for manual: cena × ilosc = 500×1 = 500\n  - New m_materialy = 31.85×500 + 500 = 16425\n  - r_plus_m = 16425 + 3450 = 19875\n  - razem = 19875 × 1.30 = 25837.50\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "Kosztorys pozycja created with link to pozycja_biblioteka",
        "Składowe materiały and robocizna copied from library with correct values",
        "kosztorys_pozycje_view returns correct m_jednostkowy and r_jednostkowy",
        "Total materials = unit_cost × quantity for auto components",
        "Total labor = unit_cost × quantity for auto components",
        "Markup calculated as (materials + labor) × narzut_percent / 100",
        "Changing quantity recalculates all totals correctly",
        "Manual component (is_manual=true) adds flat amount to totals",
        "Manual component uses ilosc × cena (not norma × cena × parent_ilosc)",
        "All calculations use toBeCloseTo for decimal precision",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": false,
      "notes": "View calculation: auto = SUM(price×norma) per unit, then ×quantity. Manual = SUM(price×ilosc) flat. Total = (auto_per_unit × qty + manual) × (1 + narzut/100). Use kosztorys_pozycje_view for assertions.",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-005",
      "title": "Test pozycja-do-umowy: Kosztorys -> Umowy via generate_umowy_draft",
      "description": "Create `tests/pozycja-do-umowy.test.ts`.\n\nVerifies the full chain: kosztorys → generate_umowy_draft RPC → umowy → umowa_pozycje → umowa_pozycje_zrodla → kosztorys_skladowe_robocizna.\n\n**Setup (beforeAll):**\n1. Create test org\n2. Build full estimate chain (like US-004):\n   - Pozycja biblioteczna + podwykonawca Kowalski\n   - Projekt → rewizja\n   - Kosztorys pozycja (ilosc=320, narzut=30)\n   - 2 składowe robocizny: montaż (norma=0.3, stawka=15), szpachlowanie (norma=0.2, stawka=12)\n3. Lock revision: UPDATE rewizje SET is_locked=true, locked_at=NOW()\n4. Accept revision via RPC: supabase.rpc('change_project_status', { p_projekt_id, p_new_status: 'ofertowanie' }) then supabase.rpc('change_project_status', { p_projekt_id, p_new_status: 'realizacja', p_rewizja_id })\n\nIMPORTANT: The state machine requires: draft → ofertowanie (needs locked revision) → realizacja (needs rewizja_id, marks is_accepted=true). The generate_umowy_draft function checks is_accepted=true.\n\n**Test: 'generate_umowy_draft creates contract for subcontractor'**\n- Call supabase.rpc('generate_umowy_draft', { p_projekt_id, p_rewizja_id })\n- Query umowy where projekt_id = projekt.id\n- Assert exactly 1 umowa created\n- Assert umowa.podwykonawca_id = kowalski.id\n- Assert umowa.status = 'draft'\n- Assert umowa.rewizja_id = rewizja.id\n\n**Test: 'umowa_pozycje contain positions from kosztorys'**\n- Query umowa_pozycje where umowa_id = umowa.id\n- The RPC groups by (pozycja_biblioteka_id, stawka), so:\n  - If both składowe have different stawki (15 and 12), there should be 2 umowa_pozycje\n  - Each with calculated ilosc: norma × kp.ilosc (e.g., 0.3×320=96, 0.2×320=64)\n- Assert each umowa_pozycja has correct nazwa, jednostka, ilosc, stawka\n\n**Test: 'umowa_pozycje_zrodla links back to kosztorys_skladowe_robocizna'**\n- Query umowa_pozycje_zrodla for each umowa_pozycja\n- Assert each has kosztorys_skladowa_r_id pointing to the correct kosztorys_skladowe_robocizna record\n- Assert ilosc in zrodla matches calculated ilosc\n\n**Test: 'contract status transitions work'**\n- Update umowa status: draft → wyslana → podpisana\n- Each update should succeed\n- Query and verify status at each step\n\n**Test: 'umowa_wykonanie tracks labor progress'**\n- Pick first umowa_pozycja (ilosc=96)\n- Insert umowa_wykonanie: umowa_pozycja_id, data_wpisu='2026-01-15', ilosc_wykonana=30\n- Update umowa_pozycje: ilosc_wykonana=30, procent_wykonania = 30/96 × 100 ≈ 31.25\n- Query umowa_pozycje → assert ilosc_wykonana=30, procent_wykonania close to 31.25\n- Insert another wpis: ilosc_wykonana=66 (total: 96)\n- Update: ilosc_wykonana=96, procent_wykonania=100\n- Verify\n\nNOTE: umowa_wykonanie is just a log. The ilosc_wykonana and procent_wykonania on umowa_pozycje must be updated separately (there's no trigger for auto-calculation).\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "State machine transition: draft → ofertowanie → realizacja works",
        "generate_umowy_draft creates 1 umowa per distinct podwykonawca",
        "Umowa linked to correct podwykonawca, projekt, rewizja",
        "umowa_pozycje contain correct quantities (norma × ilosc)",
        "umowa_pozycje grouped by pozycja_biblioteka_id and stawka",
        "umowa_pozycje_zrodla links each pozycja back to kosztorys_skladowe_robocizna",
        "Contract status transitions: draft → wyslana → podpisana",
        "umowa_wykonanie records created and ilosc/procent updated",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "generate_umowy_draft RPC requires is_accepted=true on the rewizja. State machine: draft→ofertowanie→realizacja. The RPC groups by (pozycja_biblioteka_id, stawka) — different stawki = different umowa_pozycje. umowa_wykonanie is a log, doesn't auto-update procent.",
      "dependsOn": ["US-004"]
    },
    {
      "id": "US-006",
      "title": "Test pozycja-do-zamowienia: Kosztorys -> Zamówienia via generate_zamowienia_draft",
      "description": "Create `tests/pozycja-do-zamowienia.test.ts`.\n\nVerifies: kosztorys → generate_zamowienia_draft RPC → zamowienia → zamowienie_pozycje → zamowienie_pozycje_zrodla → kosztorys_skladowe_materialy.\n\n**Setup (beforeAll):**\n1. Create test org\n2. Build full estimate chain:\n   - Pozycja + dostawca Bricoman + 2 produkty (profil cena=8.50, płyta cena=22.00)\n   - Projekt → rewizja\n   - Kosztorys pozycja (ilosc=320, narzut=30)\n   - 2 składowe materiały: profil (norma=0.9, cena=8.50, dostawca=bricoman), płyta (norma=1.1, cena=22.00, dostawca=bricoman)\n3. Lock + accept revision (same state machine as US-005)\n\n**Test: 'generate_zamowienia_draft creates PO for supplier'**\n- Call supabase.rpc('generate_zamowienia_draft', { p_projekt_id, p_rewizja_id })\n- Query zamowienia where projekt_id\n- Assert exactly 1 zamowienie\n- Assert zamowienie.dostawca_id = bricoman.id\n- Assert status = 'draft'\n\n**Test: 'zamowienie_pozycje contain materials from kosztorys'**\n- Query zamowienie_pozycje where zamowienie_id\n- The RPC groups by (produkt_id, cena), so expect 2 rows:\n  - Profil C50: ilosc_zamowiona = 0.9×320 = 288, cena_jednostkowa = 8.50\n  - Płyta GK: ilosc_zamowiona = 1.1×320 = 352, cena_jednostkowa = 22.00\n- Assert produkt_id, nazwa, ilosc_zamowiona, cena_jednostkowa for each\n\n**Test: 'zamowienie_pozycje_zrodla links back to kosztorys_skladowe_materialy'**\n- Query zamowienie_pozycje_zrodla for each pozycja\n- Assert kosztorys_skladowa_m_id points to correct record\n- Assert ilosc matches\n\n**Test: 'partial delivery updates quantities'**\n- Update zamowienie status: draft → wyslane\n- Create zamowienie_dostawy: zamowienie_id, data_dostawy='2026-02-01', numer_wz='WZ/001'\n- Create zamowienie_dostawy_pozycje: zamowienie_dostawa_id, zamowienie_pozycja_id=profil, ilosc_dostarczona=100\n- Update zamowienie_pozycje for profil: ilosc_dostarczona=100\n- Query and verify ilosc_dostarczona=100\n- Update zamowienie status: wyslane → czesciowo\n\n**Test: 'full delivery completes PO'**\n- Create another delivery for remaining profil (188) and all płyta (352)\n- Update zamowienie_pozycje: profil ilosc_dostarczona=288, płyta ilosc_dostarczona=352\n- Update zamowienie status: czesciowo → dostarczone\n- Verify all quantities match\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "generate_zamowienia_draft creates 1 zamowienie per distinct dostawca",
        "Zamowienie linked to correct dostawca, projekt, rewizja",
        "zamowienie_pozycje contain correct quantities (norma × ilosc)",
        "zamowienie_pozycje grouped by produkt_id and cena",
        "zamowienie_pozycje_zrodla links each pozycja back to kosztorys_skladowe_materialy",
        "Partial delivery: ilosc_dostarczona updated correctly, status → czesciowo",
        "Full delivery: all quantities match, status → dostarczone",
        "Delivery records (zamowienie_dostawy + pozycje) created correctly",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "generate_zamowienia_draft groups by (produkt_id, cena). Uses COALESCE(p.nazwa, ksm.nazwa) for product name. Deliveries: zamowienie_dostawy is the header, zamowienie_dostawy_pozycje is per-item. ilosc_dostarczona on zamowienie_pozycje must be updated manually (no trigger).",
      "dependsOn": ["US-004"]
    },
    {
      "id": "US-007",
      "title": "Test pozycja-do-realizacji: Umowy/Zamówienia -> Realizacja wpisy",
      "description": "Create `tests/pozycja-do-realizacji.test.ts`.\n\nVerifies: umowy + zamowienia → realizacja_wpisy (cost tracking/invoices).\n\n**Setup (beforeAll):**\n1. Create test org\n2. Build full chain through kosztorys with both materials and labor\n3. Lock + accept revision, generate both umowy and zamowienia drafts\n4. Sign umowa (status → wyslana → podpisana)\n5. Send zamowienie (status → wyslane)\n\n**Test: 'create material realization entry linked to zamowienie'**\n- Insert realizacja_wpisy:\n  - organization_id, projekt_id\n  - typ='material'\n  - kwota_netto=5000.00\n  - numer_faktury='FV/2026/001'\n  - data_faktury='2026-02-01'\n  - oplacone=false\n  - zamowienie_id=zamowienie.id\n  - opis='Faktura za materiały - profil C50'\n- Query and verify all fields\n- Assert zamowienie_id is linked\n- Assert umowa_id is null\n\n**Test: 'create labor realization entry linked to umowa'**\n- Insert realizacja_wpisy:\n  - typ='robocizna'\n  - kwota_netto=3000.00\n  - numer_faktury='FV/2026/002'\n  - data_faktury='2026-02-05'\n  - oplacone=false\n  - umowa_id=umowa.id\n  - opis='Faktura za montaż - Kowalski'\n- Verify umowa_id linked, zamowienie_id null\n\n**Test: 'create other-type realization entry'**\n- Insert realizacja_wpisy:\n  - typ='inny'\n  - kwota_netto=800.00\n  - numer_faktury='FV/2026/003'\n  - opis='Transport materiałów'\n  - zamowienie_id=null, umowa_id=null\n- Verify both FKs are null\n\n**Test: 'mark entries as paid'**\n- Update all 3 wpisy: oplacone=true\n- Query and verify\n\n**Test: 'realizacja totals per project'**\n- Query realizacja_wpisy where projekt_id, aggregate:\n  - SUM(kwota_netto) = 5000+3000+800 = 8800\n  - SUM where typ='material' = 5000\n  - SUM where typ='robocizna' = 3000\n  - COUNT where oplacone=true = 3\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "Material wpis created with zamowienie_id linked",
        "Labor wpis created with umowa_id linked",
        "Other wpis created with both FKs null",
        "All wpis fields (typ, kwota, numer_faktury, data, oplacone, opis) stored correctly",
        "Marking as oplacone works",
        "Aggregate query returns correct totals per type",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "realizacja_wpisy is simple — just insert + verify. The interesting part is FK links to zamowienie or umowa. typ ENUM: material|robocizna|inny.",
      "dependsOn": ["US-005", "US-006"]
    },
    {
      "id": "US-008",
      "title": "Test full-flow: Complete end-to-end chain",
      "description": "Create `tests/full-flow.test.ts`.\n\nThis test builds the ENTIRE chain from library to realization and verifies budget consistency across all layers.\n\n**Setup (beforeAll):** Build a realistic mini-project:\n\n1. Create test org\n2. Create 2 kategorie hierarchies:\n   - BUD → BUD.01 → BUD.01.01 (Gipskarton)\n   - BUD → BUD.01 → BUD.01.02 (Malowanie) [reuse BUD and BUD.01]\n3. Create 2 dostawcy: Bricoman (BRIC), SIG (SIG)\n4. Create 3 produkty:\n   - Profil C50 (PRF-C50, mb) → Bricoman cena 8.50\n   - Płyta GK (PLY-GK, m2) → Bricoman cena 22.00\n   - Farba (FRB-01, l) → SIG cena 35.00\n5. Create 2 podwykonawcy: Kowalski (gipskarton), Malarz (malowanie)\n6. Create 2 pozycje biblioteczne:\n   - BUD.01.01.001 'Ściana GK C50' (m2) in BUD.01.01\n   - BUD.01.02.001 'Malowanie ścian' (m2) in BUD.01.02\n7. Add stawki: Kowalski→Ściana=45, Malarz→Malowanie=20\n8. Add biblioteka składowe:\n   - Ściana GK: mat[profil 0.9×8.50, płyta 1.1×22.00], rob[montaż 0.3×15, szpachla 0.2×12]\n   - Malowanie: mat[farba 0.15×35.00 from SIG], rob[malowanie 0.1×20]\n9. Create projekt 'Biuro Centrum', powierzchnia=1000\n10. Create rewizja\n11. Add 2 kosztorys pozycje:\n    - Ściana GK: ilosc=320, narzut=30\n    - Malowanie: ilosc=500, narzut=25\n12. Copy all składowe from library to kosztorys\n13. Lock revision, transition to ofertowanie, then realizacja\n14. Generate umowy + zamówienia via RPC\n\n**Test: 'kosztorys totals are correct'**\n- Query kosztorys_pozycje_view for both pozycje\n- Ściana GK (320 m2, narzut 30%):\n  - m_jedn = 0.9×8.50 + 1.1×22.00 = 31.85\n  - r_jedn = 0.3×15 + 0.2×12 = 6.90\n  - razem = (31.85+6.90) × 320 × 1.30 = 16120.00\n- Malowanie (500 m2, narzut 25%):\n  - m_jedn = 0.15×35 = 5.25\n  - r_jedn = 0.1×20 = 2.00\n  - razem = (5.25+2.00) × 500 × 1.25 = 4531.25\n- Query rewizje_summary → suma_razem should be 16120 + 4531.25 = 20651.25\n\n**Test: 'umowy generated correctly per podwykonawca'**\n- Query umowy → expect 2 (one for Kowalski, one for Malarz)\n- Kowalski umowa: umowa_pozycje should have labor from Ściana GK\n- Malarz umowa: umowa_pozycje should have labor from Malowanie\n- Sum of all umowa_pozycje values ≈ total labor from kosztorys (without markup)\n\n**Test: 'zamowienia generated correctly per dostawca'**\n- Query zamowienia → expect 2 (one for Bricoman, one for SIG)\n- Bricoman: profil 288, płyta 352\n- SIG: farba 75 (0.15×500)\n- Sum of all zamowienie_pozycje values ≈ total materials from kosztorys (without markup)\n\n**Test: 'budget consistency across layers'**\n- Kosztorys labor total (no markup): Ściana(6.90×320) + Malowanie(2.00×500) = 2208 + 1000 = 3208\n- Umowy total: SUM of all umowa_pozycje (ilosc × stawka) should also equal 3208 (since generate copies exact amounts)\n  Actually: umowa groups by stawka, so verify per-umowa totals\n- Kosztorys material total (no markup): Ściana(31.85×320) + Malowanie(5.25×500) = 10192 + 2625 = 12817\n- Zamowienia total: SUM of all zamowienie_pozycje (ilosc × cena) should equal 12817\n\n**Test: 'realizacja tracks spending against budget'**\n- Add realizacja_wpisy:\n  - Material: 5000 PLN (zamowienie Bricoman)\n  - Robocizna: 2000 PLN (umowa Kowalski)\n- Aggregate: total_spent = 7000, budget = 20651.25\n- Verify: spending is within budget\n\n**Cleanup (afterAll):** cleanupOrganization(orgId)",
      "acceptanceCriteria": [
        "Full chain built: 2 kategorie → 2 pozycje → materials + labor → kosztorys → accept → generate umowy + zamówienia",
        "Kosztorys view calculations correct for both pozycje",
        "rewizje_summary aggregates match sum of individual pozycje",
        "2 umowy created (one per podwykonawca) with correct pozycje",
        "2 zamowienia created (one per dostawca) with correct pozycje",
        "Labor budget consistency: kosztorys labor total = sum of umowy values",
        "Material budget consistency: kosztorys material total = sum of zamowienia values",
        "Realizacja entries track against budget correctly",
        "npm run test passes for this file",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "This is the ultimate integration test. Budget consistency: kosztorys totals (no markup) should match umowy+zamowienia totals. The markup is profit — it's NOT included in procurement costs.",
      "dependsOn": ["US-002", "US-003", "US-004", "US-005", "US-006", "US-007"]
    },
    {
      "id": "US-009",
      "title": "Fix all test failures + build + lint pass",
      "description": "Run all tests and fix any failures. Then verify the full project still builds.\n\n**Step 1:** Run `npm run test` and fix any failures.\nCommon issues to watch for:\n- UUID handling — Supabase returns strings\n- Decimal precision — use toBeCloseTo(expected, 1) for money calculations\n- Race conditions — afterAll cleanup might fail if tests time out\n- RLS blocking — make sure service_role key is used (bypasses RLS)\n- Unique constraint violations — use unique slugs/codes per test (include timestamp)\n- Trigger side effects — pelny_kod trigger auto-generates, numer auto-increments\n- State machine requirements — must lock revision before ofertowanie, must accept before realizacja\n- is_manual constraint — if is_manual=true, ilosc MUST be NOT NULL\n\n**Step 2:** Run `npm run build` — must pass.\nThe test files are in tests/ and excluded from Next.js build, but vitest.config.ts and any type imports must be clean.\n\n**Step 3:** Run `npm run lint` — should pass.\n\n**Step 4:** If any test file needed changes, re-run `npm run test` to confirm all pass.\n\nFinal state: `npm run test` and `npm run build` both pass with 0 errors.",
      "acceptanceCriteria": [
        "npm run test passes — all test files green",
        "npm run build passes without errors",
        "npm run lint passes",
        "No flaky tests — run twice to confirm",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "Common fixes: decimal precision (toBeCloseTo), unique slugs with timestamps, proper state machine transitions. Tests should be deterministic — no shared state between test files.",
      "dependsOn": ["US-008"]
    }
  ]
}
